# Generate boot.scr.uimg:
# ./tools/mkimage -C none -A arm -T script -d boot.src.cmd boot.scr.uimg
#
#########################################################################
# SAMPLE BOOT SCRIPT: PLEASE DON'T USE this SCRIPT in REAL PRODUCT
#########################################################################
# this script is only a OpenSTLinux helper to manage multiple target with the
# same bootfs, for real product with only one supported configuration change the
# bootcmd in U-boot or use the normal path for extlinux.conf to use DISTRO
# boocmd (generic distibution); U-Boot searches with boot_prefixes="/ /boot/":
# - /extlinux/extlinux.conf
# - /boot/extlinux/extlinux.conf
#########################################################################

echo "Executing SCRIPT on target=${target}"

# M4 Firmware load
env set m4fw_name "rproc-m4-fw.elf"
env set m4fw_addr ${kernel_addr_r}
env set boot_m4fw 'rproc init; rproc load 0 ${m4fw_addr} ${filesize}; rproc start 0'

# boot M4 Firmware when available
env set scan_m4fw 'if test -e ${devtype} ${devnum}:${distro_bootpart} ${m4fw_name};then echo Found M4 FW $m4fw_name; if load ${devtype} ${devnum}:${distro_bootpart} ${m4fw_addr} ${m4fw_name}; then run boot_m4fw; fi; fi;'

# load specific yellow splash screen
env set load_yellow_splash 'load mmc 0:4 0xc4300000 splash_yellow.bmp; bmp display 0xc4300000;'
# for efi boot
env set localcmd_efi_basci 'run load_yellow_splash; setenv bootargs "%KERNEL_CMDLINE%";load mmc 0:4 ${fdt_addr_r} ${fdtfile};load mmc 0:4 ${kernel_addr_r} zImage;if fdt addr ${fdt_addr_r}; then bootefi ${kernel_addr_r} ${fdt_addr_r};else bootefi ${kernel_addr_r} ${fdtcontroladdr};fi'
efidebug boot add -b 0000 'kernel' mmc 0:4 zImage -s 'console=ttySTM0,115200 rootwait root=PARTLABEL=rootfs bootmgr0'
efidebug boot add -b 0001 'signkernel' mmc 0:4 zImage.signed -s 'console=ttySTM0,115200 rootwait root=PARTLABEL=rootfs bootmgr3-signed'
efidebug boot add -b 0002 'rtkernel' mmc 0:4 zImage-rt -s 'console=ttySTM0,115200 rootwait root=PARTLABEL=rootfs bootmgr1'
efidebug boot order 0000

env set localcmd_efi_bootmgr 'run load_yellow_splash;load mmc 0:4 ${fdt_addr_r} ${fdtfile};if fdt addr ${fdt_addr_r}; then bootefi bootmgr ${fdt_addr_r};else bootefi bootmgr ${fdtcontroladdr};fi'
env set localcmd_efi_bootmgr_signed 'run load_yellow_splash;load mmc 0:4 0xc4100000 uefi-certificates/PK.auth;setenv -e -nv -bs -rt -at -i 0xc4100000:$filesize PK;load mmc 0:4 0xc4100000 uefi-certificates/KEK.auth;setenv -e -nv -bs -rt -at -i 0xc4100000:$filesize KEK;load mmc 0:4 0xc4100000 uefi-certificates/db.auth;setenv -e -nv -bs -rt -at -i 0xc4100000:$filesize db; run localcmd_efi_bootmgr'

env set defaultcmd 'load mmc 0:4 ${fdt_addr_r} ${fdtfile};setenv bootargs "%KERNEL_CMDLINE%";load mmc 0:4 ${kernel_addr_r} zImage; bootz ${kernel_addr_r} - ${fdt_addr_r}'

# to boot efi signed kernel
env set localcmd_signed 'efidebug boot next 0001; run localcmd_efi_bootmgr_signed;'

env set localcmd 'run localcmd_efi_bootmgr;'

# Update the DISTRO command to search in sub-directory and load M4 firmware
env set boot_prefixes "/${boot_device}${boot_instance}_"
env set boot_extlinux "run scan_m4fw;${boot_extlinux}"

# save the boot config for the 2nd boot
env set boot_targets ${target}

# when {boot_device} = nor, use ${target} = the location of U-Boot
# script boot.scr.img found in DISTRO script
# value can be "mmc0" (SD Card), "mmc1" (eMMC) or "ubifs0" (NAND)

if test ${target} = mmc0; then
    if test -d ${devtype} ${devnum}:${distro_bootpart} /mmc0_extlinux; then
        env set boot_prefixes "/mmc0_"
    fi
elif test ${target} = mmc1; then
    if test -d ${devtype} ${devnum}:${distro_bootpart} /mmc1_extlinux; then
        env set boot_prefixes "/mmc1_"
    fi
elif test ${target} = ubifs0; then
    if test -d ${devtype} ${devnum}:${distro_bootpart} /nand0_extlinux; then
        env set boot_prefixes "/nand0_"
    fi
fi

if test -e ${devtype} ${devnum}:${distro_bootpart} ${boot_prefixes}extlinux/${board_name}_extlinux.conf; then
    echo FOUND ${boot_prefixes}extlinux/${board_name}_extlinux.conf
    env set boot_syslinux_conf "extlinux/${board_name}_extlinux.conf"
fi

# don't save the updated content of bootfile variable to avoid conflict
env delete bootfile

# save the boot config the 2nd boot (boot_prefixes/boot_extlinux)
env save

# start the correct exlinux.conf
run bootcmd_${target}

echo SCRIPT FAILED... ${boot_prefixes}${boot_syslinux_conf} not found !

# restore environment to default value when failed
env default boot_targets
env default boot_prefixes
env default boot_extlinux
env default boot_syslinux_conf
env save

